#!/usr/bin/env bash

# Load functions
if [[ -d "${HOME}/.functions.d" ]]; then
  # shellcheck disable=1090
  for file in "${HOME}"/.functions.d/*.sh; do . "$file"; done
fi

# Miscellaneous Functions

# Check if root
is_root() { [[ $EUID == 0 ]] ;}

# Check if command exists
is_cmd() { command -v "$@" >/dev/null 2>&1 ;}

# Create a directory and jump directly into it
mcd() { mkdir -p "$1" && cd "$1" || return ;}

# Inspect a certificate
cert_inspect(){
  openssl x509 -in "$1" -text -noout
}

# Vlad's TMUX layout
vtmux(){
  SESSION1='VLAD'
  # SESSION2='OTHER'
  PRJ_DIR="${HOME}/Dropbox/Projects"

  if ! tmux has-session -t "$SESSION1"; then
    # PRJ
    tmux new-session -n 'PRJ' -d -s "$SESSION1" -c "$PRJ_DIR"
    tmux split-window -h -t "${SESSION1}:1" -c "$PRJ_DIR"
    tmux split-window -v -t "${SESSION1}:1" -c "$PRJ_DIR"

    # # REMOTE WINDOW
    # tmux new-window -n 'REMOTE' -t "$SESSION1"
    # tmux split-window -h -t "${SESSION1}:2"
    # tmux split-window -v -t "${SESSION1}:2"

    # # OTHER SESSION
    # tmux new-session -n 'OGA' -d -s "$SESSION2" -c "$PRJ_DIR"
    # tmux split-window -h -t "${SESSION2}:1" -c "${PRJ_DIR}/Cosmin"
    # tmux split-window -v -t "${SESSION2}:1" -c "${PRJ_DIR}/Cosmin"

    # # SEND COMMAND
    # tmux send-keys -t "${SESSION2}:1.1" 'mycmd' Enter C-l
    # tmux send-keys -t "${SESSION2}:1.2" 'mycmd' Enter C-l
    # tmux send-keys -t "${SESSION2}:1.3" 'mycmd' Enter C-l

    # Select start-up window
    tmux select-window -t "${SESSION1}:1"
    tmux select-pane -t "${SESSION1}:1.1"
  fi

  tmux attach-session -t "$SESSION1"
}

# VMware
vmware_install() {
  (
  cd "$(mktemp -d)" || return
  sudo apt-get --quiet --yes install build-essential "linux-headers-$(uname -r)"
  tar zxvf "/media/$(whoami)/VMware\\ Tools/VMwareTools-*.tar.gz"
  sudo ./vmware-tools-distrib/vmware-install.pl -d
  )
}
vmware_refresh() { sudo vmware-config-tools.pl -d ;}

# Start an HTTP server from a directory, optionally specifying the port
server() {
  local port="${1:-8000}";
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Extract most know archives with one command
extract () {
  if [ -f "$1" ] ; then
    case $1 in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar e "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)     echo "'$1' cannot be extracted via extract()" ;;
       esac
   else
       echo "'$1' is not a valid file"
   fi
}

# CHROME
# USAGE: open_chrome -s -r=oga
open_chrome(){
  # vars
  local var scratch remote tmpdir chrome port proxy

  # defaults
  scratch=false
  tmpdir="$(mktemp -d -t 'chrome-unsafe_data_dir')"
  chrome='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome'
  port='8523'

  # argumets
  for var in "$@"; do
    if [[ "$var" == -s ]]; then
      scratch=true
    elif [[ "$var" =~ -r=.* ]]; then
      remote=${var//-r=/}
    fi
  done

  if [ -n "${remote}" ]; then
    proxy="--proxy-server=socks5://localhost:${port}"
    ssh="ssh -vXNCD $port $remote"
  else
    proxy='--proxy-server=direct://'
    ssh=''
  fi

  if $scratch; then
    chrome="${chrome} --disable-sync --disable-first-run-ui --no-default-browser-check --no-first-run --user-data-dir='${tmpdir}'"
  fi

  sh -c "$chrome $proxy https://www.whatismyip.com" >/dev/null 2>&1 &
  sh -c "$ssh"
}

# SSH Tmux
ssh_tmux(){
  ssh -t "$@" "tmux new-session -s vgh || tmux attach-session -t vgh"
}

# SSH Tunnel
ssh_tunnel(){
  # shellcheck disable=SC2029
  ssh -vXNCD "$1" "$2"
}

# SSH
add_public_key(){
  ssh "$@" "mkdir -p ~/.ssh && cat >>  ~/.ssh/authorized_keys" \
    < ~/.ssh/id_rsa.pub
}

# Timezones
now_in(){
  for t in US/Central America/Phoenix Europe/Bucharest US/Eastern; do
    zdump $t
  done
}

# Watch directory for changes and execute command
watch_dir(){
  local dir=$1
  shift
  local cmd=$*
  fswatch -0 -o -r "$dir" | while read -r -d ""; do
    $cmd
  done
}

# Simple bash server
simple_bash_server(){
  while true; do
    HOST=$(hostname -s)
    HTML="
<html>
  <head>
    <title>Simple BASH Server</title>
    <style>body {margin-top:   40px; background-color: #333;}</style>
  </head>
  <body>
    <div style=color:white;text-align:center>
      <h1>Running on ${HOST}</h1>
    </div>
  </body>
</html>
  "
    echo "$HTML" | nc -q 0 -l -p 80
  done
}

# Docker Functions

# Kill all running containers.
docker_killall(){
  for c in $(docker ps -q 2>/dev/null); do docker kill "$c"; done
}

# Delete all stopped containers, untagged images, volumes, networks, etc.
docker_clean(){
  docker system prune --force
}

docker_delstopped(){
  local name=$1
  local state; state=$(docker inspect --format "{{.State.Running}}" "$name" 2>/dev/null)

  if [[ "$state" == "false" ]]; then
    docker rm "$name"
  fi
}

# Runs docker exec in the latest container
docker_exec_last(){
  docker exec -it "$(docker ps -a -q -l)" /bin/bash
}

# Miscellaneous GPG Functions
# Load GPG Agent
gpg_agent_load(){
  # Do not load if tty is not installed
  if ! is_cmd tty; then return; fi

  # Do not load if the agent is not installed
  if ! is_cmd gpg-agent; then return; fi

  # Do not load if gpg-connect-agent is not installed
  if ! is_cmd gpg-connect-agent; then return; fi

  # Do not load if gpg-connect-agent is not installed
  if ! is_cmd gpgconf; then return; fi

  # Use a TTY for GPG
  GPG_TTY="$(tty)"; export GPG_TTY
  # Start the gpg-agent if not already running
  if ! pgrep -x -u "${USER}" gpg-agent >/dev/null 2>&1; then
    gpg-connect-agent /bye >/dev/null 2>&1
    gpg-connect-agent updatestartuptty /bye >/dev/null
  fi
}

# Reload GPG Agent
gpg_agent_reload(){
  echo 'Reloading GPG Agent...'
  gpgconf --reload gpg-agent
}

# Unload GPG Agent
gpg_agent_kill(){
  echo 'Killing GPG Agent...'
  gpgconf --kill gpg-agent
}

# Restart GPG Agent
gpg_agent_restart(){
  echo 'Stopping GPG Agent...'
  gpg_agent_kill
  echo 'Starting GPG Agent...'
  gpg_agent_load
}

# Test encryption and decryption of phrase
gpg_agent_test(){
  echo 'hello world' | gpg -e -r "$(whoami)" | gpg -d
}

# Sync files to/from AWS S3
sync_s3(){
  local src="${1:?Must specify source as the 1st argument}"
  local dst="${2:?Must specify destination as the 2nd argument}"

  # Make sure directory exists
  if [[ ! "$dst" =~ s3:// ]]; then
    mkdir -p "$dst"
  fi

  echo "Sync ${src} to ${dst}"
  # https://docs.aws.amazon.com/cli/latest/topic/return-codes.html
  aws s3 sync "${src}" "${dst}" --sse --delete --exact-timestamps || true ;
}

# Upload encrypted secrets to S3
upload_encrypted_secrets(){
  local DIR ARC REC
  DIR="${HOME}/Dropbox/Projects/.secrets"
  ARC="s3://vgsec/$(date +"%Y%m%d_%H%M%S").tar.xz.gpg"
  REC="${GPG_RECIPIENT:?Must specify GPG recipient}"

  echo "Encrypting ${DIR}"
  tar cJ -C "$DIR" . | gpg --encrypt --sign --recipient "$REC" --cipher-algo AES256 --s2k-digest-algo SHA512 | aws s3 cp --no-progress --sse --acl private - "${ARC}"
  echo "Secret files uploaded to ${ARC}"
}
